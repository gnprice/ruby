
Detailed notes.

v1_9_3_194 with -pg:

$ n=10000; time ruby -I ~/src/ruby-require-torture -e n=$n'; (1..n).each {|i| require "isolated/#{i}"}'
real	0m6.341s


$ n=10000; time perf record -g ruby -I ~/src/ruby-require-torture -e n=$n'; (1..n).each {|i| require "isolated/#{i}"}'
real	0m6.549s


$ perf report -g fractal,5 -d ruby.profile
[and hit E]

-  32.16%  ruby  rb_string_value_ptr
   - rb_string_value_ptr
      - 88.24% rb_feature_p
           rb_require_safe
           vm_call_method
           vm_exec_core
           vm_exec
           rb_yield
           range_each
           vm_call_method
           vm_exec_core
           vm_exec
           rb_iseq_eval_main
           ruby_exec_internal
           ruby_run_node
           main
           __libc_start_main
      - 11.76% rb_require_safe
           vm_call_method
           vm_exec_core
           vm_exec
           rb_yield
           range_each
           vm_call_method
           vm_exec_core
           vm_exec
           rb_iseq_eval_main
           ruby_exec_internal
           ruby_run_node
           main
           __libc_start_main
-  27.41%  ruby  rb_feature_p
   - rb_feature_p
      - 99.45% rb_require_safe
           vm_call_method
           vm_exec_core

partly abbreviated:

-  32.16%  ruby  rb_string_value_ptr
   - rb_string_value_ptr
      - 88.24% rb_feature_p
           rb_require_safe
           vm_call_method
           vm_exec_core
           vm_exec
           rb_yield
           range_each
           vm_call_method
           vm_exec_core
           vm_exec
           rb_iseq_eval_main
           ruby_exec_internal
           ruby_run_node
           main
           __libc_start_main
      + 11.76% rb_require_safe
-  27.41%  ruby  rb_feature_p
   - rb_feature_p
      + 99.45% rb_require_safe
      + 0.55% vm_call_method
-  22.10%  ruby  loaded_feature_path.part.2
   - loaded_feature_path.part.2
      + 95.00% rb_feature_p
      + 5.00% rb_require_safe
+   2.76%  ruby  0x109f0
+   1.50%  ruby  file_expand_path


more abbreviated:

-  32.16%  ruby  rb_string_value_ptr
   - rb_string_value_ptr
      + 88.24% rb_feature_p
      + 11.76% rb_require_safe
-  27.41%  ruby  rb_feature_p
   - rb_feature_p
      + 99.45% rb_require_safe
-  22.10%  ruby  loaded_feature_path.part.2
   - loaded_feature_path.part.2
      + 95.00% rb_feature_p
      + 5.00% rb_require_safe
+   2.76%  ruby  0x109f0
+   1.50%  ruby  file_expand_path


summarized:

78% rb_feature_p() !
  27% directly
  28% in rb_string_value_ptr()
  21% in loaded_feature_path()
   2% other
22% other (including all GC, and some rb_feature_p() I missed)

3.78% rb_string_value_ptr in rb_require_safe


Hmm, interesting.  When I try perf on the 'bundle exec rails runner "p 1"'
test, the GC dominates.  Unfortunately I can't get that to run with a
-pg build, so I can't get a call-graph profile, which is the smoking
gun on allocation.  But that suggests that the expanded-$LOAD_PATH
cache -- which cuts allocation way down to middling-bloated -- is the
key change for that test, which is the practical one.



rb_feature_p simplified for the callsite
      if ((ft = rb_feature_p(ftptr, 0, FALSE, FALSE, &loading)) == 'r')
but kept coherent:

  rb_feature_p(const char *feature, const char *ext, int rb, int expanded, const char **fn)
  {
      VALUE v, features, p, load_path = 0;
      const char *f;
      long len, n;

      len = strlen(feature);
      features = get_loaded_features();
      for (i = 0; i < RARRAY_LEN(features); ++i) {
          v = RARRAY_PTR(features)[i];
 ->       f = StringValuePtr(v);
          if ((n = RSTRING_LEN(v)) < len) continue;
          if (strncmp(f, feature, len) != 0) {
              if (!load_path) load_path = rb_get_expanded_load_path();
 ->           if (!(p = loaded_feature_path(f, n, feature, len, 0, load_path)))
                  continue;
          }
          return 'u';
      }

And simplified more, still coherent:

  rb_feature_p(const char *feature, const char *ext, int rb, int expanded, const char **fn)
  {
      VALUE v, features, load_path;
      const char *f;
      long len, n;

      load_path = rb_get_expanded_load_path();
      len = strlen(feature);

      features = get_loaded_features();
      for (i = 0; i < RARRAY_LEN(features); ++i) {
          v = RARRAY_PTR(features)[i];
 ->       f = StringValuePtr(v);
          if ((n = RSTRING_LEN(v)) < len) continue;
          if (strncmp(f, feature, len) != 0) {
 ->           if (loaded_feature_path(f, n, feature, len, 0, load_path))
                  return 'u';
          }
      }

Simplified to non-code:

  rb_feature_p(const char *feature, const char *ext, int rb, int expanded, const char **fn)
  {
      features = /* $LOADED_FEATURES */;
      /* for v in features */ {
 ->       f = StringValuePtr(v);
          if (strncmp(f, feature, /*feature.size*/) != 0) {
 ->           if (loaded_feature_path(f, /*f.size*/, feature, /*feature.size*/))
                  return 'u';
          }
      }
