
Sketch of lightning talk:

I'm going to talk about a problem, and some progress toward a
solution.

Ruby is really slow to start up.

 (slide:  (All light-on-black.)
   Problem: Ruby startup time
 )

And by Ruby I mean MRI; though if you've used JRuby you know that JVM
startup is no picnic either.  So an app running on MRI can be really
slow to start up.  Here's the Rails app that is our frontend at
Solano Labs:

 (slide: (with 1.9.2-p290; better perh. to redo with latest)
   $ date; bundle exec rails c
   Mon Oct 29 18:26:11 PDT 2012
   Time.now
   [waiting, waiting...]
 )

and I would stand here and move on precisely as soon as the prompt
would come up, but that would take much too long for a lightning talk.
It's about 36 seconds.

 (slide:
   [same, and then]
   Loading development environment (Rails 3.0.17)
   irb(main):001:0> Time.now
   => 2012-10-29 18:26:47 -0700
 )

That really bites when you're trying to get work done.


So let's profile.

 ['perf report' output from latest release; and summarize with
  1-3 percentages]

benchmark, pure require

  $ time ruby -I reqtest -e '(1..10000).each {|i| require "#{i}"}'

Here's what the profiler shows:

 (slide briefly, as a visual rather than to read:
  $ perf record -g ruby ...
  $ perf report -g fractal,5 -d ruby.profile
  -  32.16%  ruby  rb_string_value_ptr
     - rb_string_value_ptr
        - 88.24% rb_feature_p
             rb_require_safe
             vm_call_method
             vm_exec_core
             [...]
             __libc_start_main
        + 11.76% rb_require_safe
  -  27.41%  ruby  rb_feature_p
     - rb_feature_p
        + 99.45% rb_require_safe
        + 0.55% vm_call_method
  -  22.10%  ruby  loaded_feature_path.part.2
     - loaded_feature_path.part.2
        + 95.00% rb_feature_p
        + 5.00% rb_require_safe
  +   2.76%  ruby  0x109f0
  +   1.50%  ruby  file_expand_path
 )

OK, that's a lot of data.  If you add it up:

  78% (*) rb_feature_p() !
    27% directly
    28% in rb_string_value_ptr()
    21% in loaded_feature_path()
     2% other
  22% other (including all GC, and some rb_feature_p() I missed)

  (*) an *underestimate*

Seventy-eight percent of the time, at least, is all in one function,
rb_feature_p, either in that function's own code or in a couple of
functions it calls.  We're spending more than three-quarters of the
time just there.

So OK, let's make that fast.  What is this function?

[XXX]
  78% (*) rb_feature_p() !
    78% called by (search_required inlined into) rb_require_safe()
        (tail-called by rb_f_require(),) called by vm_call_method()
        called by vm_exec_core()
  22% other (including all GC, and some rb_feature_p() I missed)

  (*) an *underestimate*

Well, the function that calls it is rb_require_safe(), which
implements the Ruby Kernel method require().  So we're 
[/XXX]

 (slide, briefly as a visual
  load.c:

  static int
  rb_feature_p(const char *feature, const char *ext, int rb, int expanded, const char **fn)
  {
      VALUE v, features, p, load_path = 0;
      const char *f, *e;
      long i, len, elen, n;
      st_table *loading_tbl;
      st_data_t data;
      int type;

      if (fn) *fn = 0;
      if (ext) {
          elen = strlen(ext);
          len = strlen(feature) - elen;
          type = rb ? 'r' : 's';
 )

It's in load.c, the file that implements the 'require' method.

[XXX]
It's called from
several places, but mostly from this line:

  static int
  search_required(VALUE fname, volatile VALUE *path, int safe_level)
  {
      /* side codepaths excluded */
      char *ftptr, *loading;
      ftptr = RSTRING_PTR(fname);
 ->   if ((ft = rb_feature_p(ftptr, 0, FALSE, FALSE, &loading)) == 'r')
          return 'r';

and here's what it does:
[/XXX]

And here's its essential logic:

  rb_feature_p(const char *feature, const char *ext, int rb, int expanded, const char **fn)
  {
      features = /* $LOADED_FEATURES aka $" */;
      /* for v in features */ {
 ->       f = StringValuePtr(v);
 ->       if (loaded_feature_path(f, /*f.size*/, feature, /*feature.size*/))
              return 'u';
      }
      /* also check get_loading_table() */
      return 0;
  }

It takes $LOADED_FEATURES, which is the array of all the files we've
loaded on previous require() calls.  If your Rails app uses a couple
hundred gems with a couple thousand files, as mine does, then by the
end of startup this array is two thousand elements long.

And we iterate through this array.  Every time you call 'require'.
That's what makes the startup time slow.





follow logic of profiles, but I believe then index

then cache

then discuss what's left (mostly GC)
