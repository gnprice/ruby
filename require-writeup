
require is slow in its bookkeeping; can make Rails startup 2.2x faster

=begin
Starting a large application in Ruby is slow.  Most of the startup
time is not spent in the actual work of loading files and running Ruby
code, but in bookkeeping in the 'require' implementation.  I've
attached a patch series which makes that bookkeeping much faster.
These patches speed up a large Rails application's startup by 2.2x,
and a pure-'require' benchmark by 3.4x.

These patches fix two ways in which 'require' is slow.  Both problems
have been discussed before, but these patches solve the problems with
less code and stricter compatibility than previous patches I've seen.

* Currently we iterate through $LOADED_FEATURES to see if anything
  matches the newly required feature.  Further, each iteration
  iterates in turn through $LOAD_PATH.  Xavier Shay spotted this
  problem last year and a series of patches were discussed
  (in Issue #3924) to add a Hash index alongside $LOADED_FEATURES,
  but for 1.9.3 none were merged; Masaya Tarui committed Revision r31875,
  which mitigated the problem.  This series adds a Hash index,
  and keeps it up to date even if the user modifies $LOADED_FEATURES.
  This is worth a 40% speedup on one large Rails application,
  and 2.3x on a pure-'require' benchmark.

* Currently each 'require' call runs through $LOAD_PATH and calls
  rb_file_expand_path() on each element.  Yura Sokolov (funny_falcon)
  proposed caching this last December in Issue #5767, but it wasn't
  merged.  This series also caches $LOAD_PATH, and keeps the cache up
  to date with a different, less invasive technique.  The cache takes
  34 lines of code, and is worth an additional 57% speedup in
  starting a Rails app and a 46% speedup in pure 'require'.


== Staying Compatible

With both the $LOADED_FEATURES index and the $LOAD_PATH cache,

* we exactly preserve the semantics of the user modifying $LOAD_PATH
  or $LOADED_FEATURES;

* both $LOAD_PATH and $LOADED_FEATURES remain ordinary Arrays, with
  no singleton methods;

* we make just one semantic change: each element of $LOAD_PATH and
  $LOADED_FEATURES is made into a frozen string.  This doesn't limit
  the flexibility Ruby offers to the programmer in any way; to alter
  an element of either array, one simply reassigns it to the new
  value.  Further, normal path-munging code which only adds and
  removes elements shouldn't have to change at all.

These patches use the following technique to keep the cache and the
index up to date without modifying the methods of $LOADED_FEATURES or
$LOAD_PATH: we take advantage of the sharing mechanism in the Array
implementation to detect, in O(1) time, whether either array has been
mutated.  We cause $LOADED_FEATURES to be shared with an Array we keep
privately in load.c; if anything modifies it, it will break the
sharing and we will know to rebuild the index.  Similarly for
$LOAD_PATH.


== Benchmarks

First, on my company's Rails application, where $LOAD_PATH.size is 207
and $LOADED_FEATURES.size is 2126.  I measured the time taken by
'bundle exec rails runner "p 1"'.

 .                Rails startup time,
 version               best of 5        speedup
 v1_9_3_194             12.197s
 v1_9_3_194+index        8.688s          1.40x
 v1_9_3_194+index+cache  5.538s          2.20x

And now isolating the performance of 'require', by requiring
16000 empty files.

 version            time, best of 5     speedup
 trunk (at r36920)      10.115s
 trunk+index             4.363s          2.32x
 trunk+index+cache       2.984s          3.39x

(The timings for the Rails application are based on the latest release
rather than trunk because a number of gems failed to compile against
trunk for me.)


== The Patches

There are four patches:

(1) Patch 1 changes no behavior at all.  It adds comments and
    simplifies a bit of code to help in understanding why patch 3 is
    correct.  42 lines, most of them comments.

(2) Patch 2 adds a function to array.c which will help us tell when
    $LOAD_PATH or $LOADED_FEATURES has been modified.  17 lines.

(3) Patch 3 adds the $LOADED_FEATURES index.  150 lines.

(4) Patch 4 adds the $LOAD_PATH cache.  34 lines.

Reviews and comments welcome -- I'm sure there's something I could do
to make these patches better.  I hope we can get some form of them
into trunk before the next release -- my life has been happier since I
switched to this version because commands in my Rails application all
run faster now, and I want every Ruby programmer to be happier in the
same way with 2.0 and ideally with 1.9.4.

=end







--- wordy version below

Starting a complex Ruby application with many dependencies can be
quite slow.  A large fraction of the time is spent not in actually
reading the files, parsing them, or constructing classes and methods,
but in the bookkeeping that the 'require' implementation performs in
order to ensure we don't require the same thing twice.  This
bookkeeping is much slower than it needs to be.  I've attached a patch
series which makes it faster.  This patch series speeds up one large
Rails application's startup by approximately 4x, and a pure-'require'
benchmark by approximately 7x.

The underlying problem was diagnosed last year before the 1.9.3
release by Xavier Shay and discussed at TODO LINKS.  That discussion
ended with a patch TODO BY which sped up the hot function loaded_feature_path,
but didn't change the inefficient fundamental algorithm.  Patches
which did fix the algorithm were rejected because they abandoned the
existing semantics that $LOAD_PATH and $LOADED_FEATURES can be changed
by Ruby code or an extension at any time.  This series uses a new idea
to fix the algorithm while preserving those semantics.

Specifically, 'require' is slow because on each 'require' call:

 * we call loaded_feature_path() for each element of $LOADED_FEATURES
   to determine if there is a match, which in turn must iterate
   through the expanded load path, for total time O(#features * #paths).
   It would be better to use a hash table to find a match in O(1) time.

 * we call rb_get_expanded_load_path(), which allocates a 4099-byte
   (on my system) buffer for each element of $LOAD_PATH, which causes
   frequent garbage collection.  It would be better to do each
   expansion once, keeping a cache of the expanded load path, so that
   typically we would do no allocation.

Both of these fixes were proposed in TODO LINKS LAST YEAR.  The
challenge is that the user can change $LOADED_FEATURES or $LOAD_PATH
at any time, and we need to keep up.  In this patch series, we do so
without altering $LOADED_FEATURES or $LOAD_PATH themselves -- they
remain normal Arrays.  Instead, we take advantage of the sharing
mechanism in the Array implementation to detect, in O(1) time, whether
they have been changed.  We cause $LOADED_FEATURES to be shared with
an Array we keep privately in load.c; if anything modifies it, it will
break the sharing and we will know to rebuild the index.  Similarly
for $LOAD_PATH and rebuilding the cached expanded load path.

There is one semantic change.  The elements of $LOADED_FEATURES and
$LOAD_PATH are now forced to be frozen strings.  This causes no
limitation on the programmer's flexibility -- anything that might have
been done by mutating a string in either one can be done by
reassigning that entry of the array instead.  Normal path-munging code
which only adds and removes elements shouldn't have to change at all
-- it can add regular strings, and we automatically freeze them.

The patches are in the following sequence:

 * 1 and 2: These add comments and simplify a bit of code.  There is
   no change in behavior, except possibly for a small speedup.

 * 3-6: These keep a hash-based index of $LOADED_FEATURES.  There is
   no change in behavior other than forcing the entries to frozen
   strings, and a large speedup.

 * 7-9: These cache the expanded $LOAD_PATH, keeping a shared-array
   snapshot to detect changes.  There is no change in behavior other
   than forcing the entries to frozen strings, and a further speedup.

-- outline below --


(Keep non-dup because orig thread long.)



=============

Benchmark results:

+part1 means v0.8part1, caching expanded load path
+part2 means v0.8part2 aka v0.8partial aka v0.8.1part2,
   caching expanded load path and indexing loaded features
+partA means v0.8.1part1, indexing loaded features
(and v0.8.2 is like v0.8.1)

Starting my company's Rails app (which runs on 1.9.2-p290;
$LOAD_PATH.size is about 200 and $LOADED_FEATURES.size about 2000):

               best of 5
v1_9_2_290       29.190 | 32.162 29.680 29.190 33.406 29.400
v1_9_2_290+part1 21.696 | 24.597 22.125 21.758 22.098 21.696
v1_9_2_290+partA 11.210 | 11.236 11.401 11.471 11.210 11.357
v1_9_2_290+part2  7.610 | 10.315  7.639  7.627  7.610  7.647

v1_9_3_194       12.197 | 13.442 12.231 12.197 12.378 12.891
v1_9_3_194+partA  8.688 |  8.688  8.703  9.582  8.691  8.691
v1_9_3_194+part2  5.538 |  5.608  5.607  5.538  5.600  5.604


Requiring N empty files.

N=16000:
               best of 5
v1_9_2_290       17.397 | 17.691 17.507 17.558 17.397 17.567
v1_9_2_290+part1 16.321 | 16.675 16.321 16.392 16.584 16.427
v1_9_2_290+partA  2.458 |  2.493  2.486  2.575  2.478  2.458
v1_9_2_290+part2  2.505 |  2.538  2.627  2.505  2.513  2.543

1.9.3.0-1ubuntu2 10.758 | 11.255 10.788 10.885 10.844 10.758
v1_9_3_194        9.591 |  9.753  9.715  9.591  9.651  9.958
trunk g9dd9041   10.115 | 10.562 10.200 10.299 10.159 10.115 (aka r36920)
trunk+0.8part0   10.078 | 10.831 10.264 10.078 10.255 10.717
trunk+0.8.2part1  4.363 |  4.542  4.380  4.399  4.404  4.363
trunk+0.8.2part2  2.984 |  3.175  3.018  2.984  3.018  3.039
